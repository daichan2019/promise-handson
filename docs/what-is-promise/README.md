## 「非同期処理」とは

### まずは「同期処理」とは何かを知る

非同期処理を理解する前に、まずは「同期処理」とは何かということから理解していきましょう。

普通、プログラムはコードが書かれた順番に上から実行されます。前の行の処理が完了してはじめて次の行の処理が実行されるわけです。

このように、書かれた順番通りにひとつずつプログラムが実行されていく仕組みを「同期処理」と言います。

JavaScript もこの仕組みで動いています。

### 「非同期処理」とは何か

では非同期処理とは何でしょうか。

非同期処理とは、あるタスクを実行をしている際に、そのタスクの完了を待たずに、他のタスクが別の処理を実行できる方式をいいます。

### ブラウザ上で「同期処理」と「非同期処理」の挙動の違いを見てみよう

実際に同期処理と非同期処理の挙動の違いがわかるサンプルを用意しました。

ブラウザで`index.html`を開きましょう。このとき`command`+`option`+`i`キーを押して、検証ツールを開くのも忘れないでください。

画面下部に、単に`clickできたね!`と、console に出力するだけの`click me!`というボタンを用意しました。
ある処理が実行されているときに、他の処理が実行できるかどうかをこのボタンをクリックすることで検証します。

ボタンをクリックし、console に`clickできたね!`と出力されることを確認しておきましょう。

ここからは、同期処理と非同期処理の違いをブラウザ上で見ていきます。

まずは、`clickしたら画面が固まってしまいます。`ボタンを click してみましょう。
その後、`clickできたね!`ボタンを押してみてください。

押せますか?
画面が固まってしまい、押そうとしてもボタンは反応せず、 console には`clickできたね!`とは出力されません。

次に、`clickしても画面が固まりません。`を押してみましょう。
立て続けに`clickできたね!`ボタンも押してみましょう。

押せますか?
押せますね。

console に`clickできたね!`が出力されるのが確認できるかと思います。

`clickしたら画面が固まってしまいます。`ボタンをクリックすると、以下の順に処理が実行されます。
`同期処理開始`~`同期処理完了`までの間に`synchronousSleep(10000)`が実行されますが、この間にはブラウザ上のどんな処理も受け付けなくなってしまいます。

```js
document.querySelector(".js-sync-button").addEventListener("click", () => {
  console.log("同期処理開始");
  synchronousSleep(10000);
  console.log("同期処理完了");
});
```

一方`clickしても画面が固まりません。`ボタンをクリックすると、以下の順に処理が実行されます。

```js
document
  .querySelector(".js-async-button")
  .addEventListener("click", async () => {
    console.log("非同期処理開始");
    await sleep(5000);
    console.log("非同期処理終了");
  });
```

何やら見慣れない`async`, `wait`の単語が出てきましたね。
`sleep`関数の中身は以下です。

```js
async function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
```

こちらにも`Promise`という見慣れない単語が出てきました。
この`Promise`こそが非同期処理を実行するのに必要なオブジェクトです。
`async/await`は`Promise`を簡潔に書けるものですが、詳しくは後述します。

### 結局「非同期」だと何がうれしいの?

実際に皆さんが見ている、あるいは使っているサイトやアプリケーションの多くでは、外部からデータを取得して、画面に表示させています。

外部からデータを取得するたびに画面が固まってしまうのは非常にイライラしませんか。

非同期的にデータを取得したり、重い処理を実行することで、ユーザはその処理の完了を待たずに、サイトを閲覧したり、アプリケーションを使う事ができます。

## 非同期処理の記述の歴史

### callback 関数を利用した書き方

JavaScript では、callback 関数を使うことで、関数の引数に関数を渡し、実行のタイミングをハンドリングすることができます。
例えば、夕食を食べた後に風呂に入る処理を考えてみましょう。

```js
function eatDinner(callback) {
  console.log("夕食を食べる");
  callback();
}

function takeABath() {
  console.log("風呂に入る");
}

eatDinner(takeABath);
```

これをブラウザの console に貼り付けると、

`夕食を食べる`
`風呂に入る`
の順で出力されることがわかると思います。

先程チラっとでた`Promise`は ES2015 から登場したのですが、それ以前は、この callback 関数を用いることで非同期処理を実現しようとしていました。

こんな具合です。

```js
function wait(ms, callback) {
  setTimeout(() => {
    callback();
  }, ms);
}

console.log("start");
wait(1000, () => {
  console.log("1");
  wait(2000, () => {
    console.log("2");
    wait(3000, () => {
      console.log("3");
    });
  });
});
```

かなりネストが深くなって、見づらいですね。
これを人は`callback地獄`と呼びました。

### Promise を使用した方法
